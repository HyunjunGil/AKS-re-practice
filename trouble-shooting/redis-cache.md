# Redis 캐시 구현 및 코드 리팩토링 과정 기록

## 1. Redis 캐시 우선 검색 로직 구현

### 문제 상황
사용자가 메시지를 추가한 후 검색할 때 두 가지 경우(Redis 캐시와 DB)에서 메시지가 나타나지 않는 문제가 발생.

### 예상했던 원인
Redis 캐시 우선 검색 로직이 제대로 구현되지 않았거나, 캐시 저장/조회 과정에서 문제가 있을 것으로 예상.

### 실제 원인 및 해결 방법
기존 코드는 DB에서만 검색하고 있었어. Redis 우선 검색 로직을 추가하여 다음과 같이 수정했어:

1. **Redis에서 먼저 검색**: 사용자별 캐시된 메시지에서 검색어 포함 여부 확인
2. **Redis 결과 있음**: 즉시 반환 (source: 'redis')
3. **Redis 결과 없음**: DB에서 검색 후 결과를 Redis에 캐시로 저장
4. **응답 형식 개선**: status, source, results, count 필드 포함

## 2. 코드 리팩토링 (클래스 기반 구조)

### 문제 상황
기존 코드는 함수들이 하나의 파일에 모두 섞여 있고, 코드 중복이 많으며, 의존성이 강하게 결합되어 있어 유지보수가 어려웠어.

### 예상했던 원인
함수형 프로그래밍 방식으로 인해 비즈니스 로직과 데이터 액세스가 분리되지 않았고, 설정과 연결 관리가 각 함수마다 중복되어 있었어.

### 실제 원인 및 해결 방법
클래스 기반 구조로 전환하여 다음과 같이 개선했어:

1. **설정 클래스들**: DatabaseConfig, RedisConfig, KafkaConfig로 설정 분리
2. **매니저 클래스들**: DatabaseManager, RedisManager, KafkaManager로 연결 관리
3. **서비스 클래스들**: MessageService, UserService, LoggingService, CacheService로 비즈니스 로직 분리
4. **의존성 주입**: 각 서비스가 필요한 매니저를 생성자로 주입받아 결합도 감소
5. **컨텍스트 매니저**: @contextmanager로 리소스 자동 정리

## 3. 프론트엔드 응답 형식 처리 수정

### 문제 상황
백엔드 응답 형식을 변경했지만, 프론트엔드에서 이를 제대로 처리하지 못하여 메시지가 잠깐 보였다가 사라지는 문제가 발생.

### 예상했던 원인
백엔드와 프론트엔드 간의 응답 형식 불일치로 인해 데이터를 제대로 파싱하지 못하는 것으로 예상.

### 실제 원인 및 해결 방법
백엔드 응답이 `[message1, message2, ...]`에서 `{"status": "success", "source": "redis", "results": [...], "count": 5}`로 변경되었는데, 프론트엔드에서 `response.data.results`에 접근하지 못했어. 다음과 같이 수정했어:

1. **응답 형식 처리**: 새로운 응답 형식을 처리하는 로직 추가
2. **호환성 유지**: 기존 형식과의 호환성 유지
3. **디버깅 정보**: 데이터 출처, 결과 개수, 응답 상태 표시
4. **콘솔 로그**: 상세한 검색 결과 정보 출력

## 4. Redis 캐시 검색 결과 source 정보 누락

### 문제 상황
Redis에서 검색한 결과에 `source` 필드가 없어서 프론트엔드에서 처리하지 못함.

### 예상했던 원인
Redis 캐시에 저장할 때 source 정보를 포함하지 않았거나, 검색 결과를 반환할 때 누락된 것으로 예상.

### 실제 원인 및 해결 방법
Redis 캐시 검색 결과에 `source: 'redis'` 필드를 추가했어:

1. **Redis 검색 결과**: `_search_messages_from_cache` 메서드에서 `message['source'] = 'redis'` 추가
2. **Redis 조회 결과**: `_get_messages_from_cache` 메서드에서 `message['source'] = 'redis'` 추가
3. **DB 결과**: `_get_messages_from_db`, `_search_messages_from_db` 메서드에서 `message['source'] = 'database'` 추가

## 5. Source 판별 로직 오류

### 문제 상황
`hasattr(messages[0], 'get')` 불필요한 체크로 인한 오류가 발생했습니다.

### 예상했던 원인
프론트엔드에서 source 판별 시 잘못된 객체 체크를 하고 있었습니다.

### 실제 원인 및 해결 방법
간단하고 명확한 source 판별 로직으로 수정했습니다:

1. **기존 코드**: `hasattr(messages[0], 'get') && messages[0].get('source') == 'redis'`
2. **수정된 코드**: `messages[0].get('source') == 'redis'`
3. **안전성**: `len(messages) > 0` 체크로 빈 배열 방지

## 6. 캐시 저장 시 Source 정보 보존

### 문제 상황
DB 결과를 Redis에 캐시할 때 source 정보가 유실되었습니다.

### 예상했던 원인
캐시 저장 과정에서 원본 메시지 객체의 source 정보가 변경되거나 누락된 것으로 예상했습니다.

### 실제 원인 및 해결 방법
캐시 시 `source: 'redis'`로 변경하여 저장하도록 수정했습니다:

1. **원본 보존**: 원본 메시지 객체는 변경하지 않음
2. **복사본 생성**: `message_copy = message.copy()`로 복사본 생성
3. **Source 변경**: `message_copy['source'] = 'redis'`로 설정
4. **캐시 저장**: 수정된 복사본을 Redis에 저장

## 7. 메시지 저장 시 Redis 캐시 추가

### 문제 상황
새 메시지를 저장할 때 Redis에 캐시로 저장하지 않아서, 저장 직후 검색 시 DB에서만 조회해야 했습니다.

### 예상했던 원인
메시지 저장 후 Redis 캐시 업데이트 로직이 누락되었습니다.

### 실제 원인 및 해결 방법
메시지 저장 시 Redis에 자동 캐시하도록 추가했습니다:

1. **DB 저장**: MariaDB에 메시지 저장
2. **ID 획득**: `cursor.lastrowid`로 삽입된 메시지 ID 가져오기
3. **Redis 캐시**: 메시지 데이터를 Redis에 TTL 1시간으로 저장
4. **키 패턴**: `user_messages:{user_id}:{message_id}` 형태로 저장

## 8. 에러 처리 및 로깅 개선

### 문제 상황
Redis 연결 실패나 캐시 오류 시 적절한 fallback 처리가 되지 않았습니다.

### 예상했던 원인
에러 처리 로직이 부족하거나 일관되지 않았습니다.

### 실제 원인 및 해결 방법
Graceful Degradation 패턴을 적용하여 개선했습니다:

1. **Redis 오류 무시**: Redis 오류 시 DB 조회로 자동 fallback
2. **로깅 강화**: 상세한 에러 정보와 경고 메시지 기록
3. **사용자 경험**: Redis 오류가 있어도 서비스는 정상 동작
4. **모니터링**: Redis 상태를 지속적으로 모니터링

## 9. 성능 최적화 및 모니터링

### 문제 상황
Redis 캐시 성능과 메모리 사용량을 모니터링할 수 없었습니다.

### 예상했던 원인
캐시 상태 조회나 성능 메트릭 수집 기능이 부족했습니다.

### 실제 원인 및 해결 방법
캐시 관리 및 모니터링 기능을 추가했습니다:

1. **캐시 상태 조회**: `/cache/status` 엔드포인트로 캐시 정보 확인
2. **캐시 클리어**: `/cache/clear` 엔드포인트로 사용자별 캐시 정리
3. **TTL 관리**: 1시간 TTL로 메모리 사용량 제한
4. **키 패턴**: 사용자별 캐시 키로 효율적 관리

## 10. 최종 검증 및 테스트

### 문제 상황
모든 수정 사항이 제대로 작동하는지 확인이 필요했습니다.

### 예상했던 원인
개별 수정 사항들이 서로 연동되어 전체 시스템이 정상 작동하는지 검증이 필요했습니다.

### 실제 원인 및 해결 방법
단계별로 검증하고 최종 테스트를 진행했습니다:

1. **Redis 캐시 검색**: 새 메시지 저장 후 Redis에서 즉시 검색 확인
2. **DB fallback**: Redis 오류 시 DB에서 정상 검색 확인
3. **프론트엔드 연동**: 응답 형식 변경 후 UI 정상 동작 확인
4. **성능 테스트**: Redis 캐시로 인한 검색 속도 향상 확인
